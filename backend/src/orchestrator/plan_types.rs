//! Plan types for the orchestrator
//!
//! Structs that represent the JSON plan generated by the planner agent.
//! The planner generates a structured plan that describes a sequence of steps
//! and their dependencies.

use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};

/// Top-level plan structure
#[derive(Debug, Clone, Serialize, Deserialize)]
#[allow(dead_code)] // Will be used in Phase 2B
pub struct Plan {
    /// Version of the plan schema (for future compatibility)
    #[serde(default = "default_version")]
    pub version: String,
    /// List of steps to execute
    pub steps: Vec<Step>,
}

fn default_version() -> String {
    "1.0".to_string()
}

/// A single step in the plan
#[derive(Debug, Clone, Serialize, Deserialize)]
#[allow(dead_code)] // Will be used in Phase 2B
pub struct Step {
    /// Unique identifier for this step (e.g., "step_1", "step_2")
    pub id: String,
    /// Task type to execute (e.g., "run_gemini", "create_file")
    pub task: String,
    /// Task-specific parameters
    #[serde(default)]
    pub params: StepParams,
    /// List of step IDs this step depends on (for parallel execution)
    /// If empty, step can run immediately
    #[serde(default)]
    pub dependencies: Vec<String>,
}

/// Task-specific parameters for a step
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
#[allow(dead_code)] // Will be used in Phase 2B
pub struct StepParams {
    /// Prompt to send (for run_gemini task)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prompt: Option<String>,

    /// Filename to create (for create_file task)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub filename: Option<String>,

    /// Reference to output from another step (e.g., "step_1.output")
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_from: Option<String>,
}

impl Plan {
    /// Validate the plan structure
    ///
    /// Checks for:
    /// - Unique step IDs
    /// - Valid task names
    /// - Valid content_from references
    /// - Valid dependencies (must reference existing steps)
    /// - No circular dependencies (must be a DAG)
    /// - Consistency between content_from and dependencies
    #[allow(dead_code)] // Will be used in Phase 2B
    pub fn validate(&self) -> Result<(), ValidationError> {
        // Check for duplicate step IDs
        let mut step_ids = std::collections::HashSet::new();
        for step in &self.steps {
            if !step_ids.insert(&step.id) {
                return Err(ValidationError::DuplicateStepId(step.id.clone()));
            }
        }

        // Check that all content_from references exist
        let valid_step_ids: std::collections::HashSet<&str> =
            self.steps.iter().map(|s| s.id.as_str()).collect();

        // Validate dependencies for each step
        for step in &self.steps {
            // Check that all dependencies reference existing steps
            for dep in &step.dependencies {
                if !valid_step_ids.contains(dep.as_str()) {
                    return Err(ValidationError::InvalidDependency {
                        step_id: step.id.clone(),
                        dependency: dep.clone(),
                    });
                }
            }

            // Check content_from references
            if let Some(ref content_from) = step.params.content_from {
                // Parse "step_1.output" -> "step_1"
                let referenced_step_id = content_from.split('.').next().unwrap_or(content_from);
                if !valid_step_ids.contains(referenced_step_id) {
                    return Err(ValidationError::InvalidReference {
                        step_id: step.id.clone(),
                        reference: content_from.clone(),
                    });
                }

                // Consistency check: if content_from references step_X, dependencies should include step_X
                if !step.dependencies.contains(&referenced_step_id.to_string()) {
                    return Err(ValidationError::InconsistentDependency {
                        step_id: step.id.clone(),
                        content_from: content_from.clone(),
                        missing_dependency: referenced_step_id.to_string(),
                    });
                }
            }

            // Validate task name
            if !is_valid_task_name(&step.task) {
                return Err(ValidationError::InvalidTaskName {
                    step_id: step.id.clone(),
                    task: step.task.clone(),
                });
            }

            // Validate required parameters for each task type
            match step.task.as_str() {
                "run_gemini" => {
                    if step.params.prompt.is_none()
                        || step
                            .params
                            .prompt
                            .as_ref()
                            .map(|p| p.is_empty())
                            .unwrap_or(true)
                    {
                        return Err(ValidationError::MissingRequiredParam {
                            step_id: step.id.clone(),
                            task: step.task.clone(),
                            param: "prompt".to_string(),
                        });
                    }
                }
                "create_file" => {
                    if step.params.filename.is_none()
                        || step
                            .params
                            .filename
                            .as_ref()
                            .map(|f| f.is_empty())
                            .unwrap_or(true)
                    {
                        return Err(ValidationError::MissingRequiredParam {
                            step_id: step.id.clone(),
                            task: step.task.clone(),
                            param: "filename".to_string(),
                        });
                    }
                }
                _ => {
                    // Unknown task type already caught by task name validation
                }
            }
        }

        // Check for circular dependencies (must be a DAG)
        self.detect_cycles()?;

        Ok(())
    }

    /// Detect circular dependencies using Depth-First Search
    ///
    /// Returns an error if a cycle is detected, otherwise Ok(())
    fn detect_cycles(&self) -> Result<(), ValidationError> {
        // Build adjacency list: step_id -> Vec<step_ids it depends on>
        // Use owned Strings to avoid lifetime issues
        let mut graph: HashMap<String, Vec<String>> = HashMap::new();
        for step in &self.steps {
            graph.insert(step.id.clone(), step.dependencies.clone());
        }

        // DFS to detect cycles
        let mut visited: HashSet<String> = HashSet::new();
        let mut recursion_stack: HashSet<String> = HashSet::new();

        for step in &self.steps {
            let step_id = step.id.clone();
            if !visited.contains(&step_id)
                && Self::has_cycle_dfs(&step_id, &graph, &mut visited, &mut recursion_stack)
            {
                return Err(ValidationError::CircularDependency {
                    step_id: step_id.clone(),
                });
            }
        }

        Ok(())
    }

    /// Helper function for cycle detection using DFS
    fn has_cycle_dfs(
        node: &str,
        graph: &HashMap<String, Vec<String>>,
        visited: &mut HashSet<String>,
        recursion_stack: &mut HashSet<String>,
    ) -> bool {
        visited.insert(node.to_string());
        recursion_stack.insert(node.to_string());

        // Check all dependencies of this node
        if let Some(dependencies) = graph.get(node) {
            for dep in dependencies {
                if !visited.contains(dep) {
                    // Recurse for unvisited dependencies
                    if Self::has_cycle_dfs(dep, graph, visited, recursion_stack) {
                        return true;
                    }
                } else if recursion_stack.contains(dep) {
                    // Found a back edge - cycle detected!
                    return true;
                }
            }
        }

        recursion_stack.remove(node);
        false
    }
}

/// Validation errors for plan structure
/// Errors that can occur during plan validation
#[derive(Debug, thiserror::Error)]
#[allow(dead_code)] // Will be used in Phase 2B
pub enum ValidationError {
    /// Multiple steps have the same ID
    #[error("Duplicate step ID: {0}")]
    DuplicateStepId(String),

    /// Step references a non-existent step (via content_from)
    #[error("Step '{step_id}' references non-existent step '{reference}'")]
    InvalidReference {
        /// ID of the step with the invalid reference
        step_id: String,
        /// The invalid reference string
        reference: String,
    },

    /// Step has an invalid task name
    #[error(
        "Step '{step_id}' has invalid task name: '{task}'. Available: run_gemini, create_file"
    )]
    InvalidTaskName {
        /// ID of the step with invalid task name
        step_id: String,
        /// The invalid task name
        task: String,
    },

    /// Step is missing a required parameter for its task type
    #[error("Step '{step_id}' (task: '{task}') missing required parameter: '{param}'")]
    MissingRequiredParam {
        /// ID of the step missing the parameter
        step_id: String,
        /// Task type of the step
        task: String,
        /// Name of the missing parameter
        param: String,
    },

    /// Step has a circular dependency (dependency chain forms a cycle)
    #[error("Step '{step_id}' has circular dependency (cycle detected)")]
    CircularDependency {
        /// ID of a step involved in the cycle
        step_id: String,
    },

    /// Step references a non-existent dependency in its dependencies array
    #[error("Step '{step_id}' references non-existent dependency '{dependency}'")]
    InvalidDependency {
        /// ID of the step with invalid dependency
        step_id: String,
        /// The invalid dependency step ID
        dependency: String,
    },

    /// Step's content_from and dependencies arrays are inconsistent
    #[error("Step '{step_id}' has inconsistent dependency: 'content_from' references '{content_from}' but 'dependencies' doesn't include '{missing_dependency}'")]
    InconsistentDependency {
        /// ID of the step with inconsistent dependencies
        step_id: String,
        /// The content_from reference string
        content_from: String,
        /// The missing dependency that should be in dependencies array
        missing_dependency: String,
    },
}

/// Check if a task name is valid
#[allow(dead_code)] // Will be used in Phase 2B
fn is_valid_task_name(task: &str) -> bool {
    matches!(task, "run_gemini" | "create_file")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_plan_deserialization() {
        let json = r#"{
            "version": "1.0",
            "steps": [
                {
                    "id": "step_1",
                    "task": "run_gemini",
                    "params": {
                        "prompt": "Write a poem"
                    },
                    "dependencies": []
                },
                {
                    "id": "step_2",
                    "task": "create_file",
                    "params": {
                        "filename": "poem.txt",
                        "content_from": "step_1.output"
                    },
                    "dependencies": ["step_1"]
                }
            ]
        }"#;

        let plan: Plan = serde_json::from_str(json).unwrap();
        assert_eq!(plan.version, "1.0");
        assert_eq!(plan.steps.len(), 2);
        assert_eq!(plan.steps[0].id, "step_1");
        assert_eq!(plan.steps[0].dependencies, Vec::<String>::new());
        assert_eq!(
            plan.steps[1].params.content_from,
            Some("step_1.output".to_string())
        );
        assert_eq!(plan.steps[1].dependencies, vec!["step_1"]);
    }

    #[test]
    fn test_plan_deserialization_missing_dependencies() {
        // Test backward compatibility: missing dependencies should default to []
        let json = r#"{
            "version": "1.0",
            "steps": [
                {
                    "id": "step_1",
                    "task": "run_gemini",
                    "params": {
                        "prompt": "Write a poem"
                    }
                }
            ]
        }"#;

        let plan: Plan = serde_json::from_str(json).unwrap();
        assert_eq!(plan.steps[0].dependencies, Vec::<String>::new());
    }

    #[test]
    fn test_plan_validation_success() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write a poem".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "create_file".to_string(),
                    params: StepParams {
                        filename: Some("poem.txt".to_string()),
                        content_from: Some("step_1.output".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_1".to_string()],
                },
            ],
        };

        assert!(plan.validate().is_ok());
    }

    #[test]
    fn test_plan_validation_duplicate_step_id() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: Default::default(),
                    dependencies: vec![],
                },
                Step {
                    id: "step_1".to_string(), // Duplicate!
                    task: "create_file".to_string(),
                    params: Default::default(),
                    dependencies: vec![],
                },
            ],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::DuplicateStepId(id)) = result {
            assert_eq!(id, "step_1");
        } else {
            panic!("Expected DuplicateStepId error");
        }
    }

    #[test]
    fn test_plan_validation_invalid_reference() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write a test".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "create_file".to_string(),
                    params: StepParams {
                        filename: Some("test.txt".to_string()),
                        content_from: Some("step_999.output".to_string()), // Invalid reference!
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
            ],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::InvalidReference { step_id, reference }) = result {
            assert_eq!(step_id, "step_2");
            assert_eq!(reference, "step_999.output");
        } else {
            panic!("Expected InvalidReference error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_invalid_task_name() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![Step {
                id: "step_1".to_string(),
                task: "invalid_task".to_string(), // Invalid!
                params: Default::default(),
                dependencies: vec![],
            }],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::InvalidTaskName { step_id, task }) = result {
            assert_eq!(step_id, "step_1");
            assert_eq!(task, "invalid_task");
        } else {
            panic!("Expected InvalidTaskName error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_missing_prompt() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![Step {
                id: "step_1".to_string(),
                task: "run_gemini".to_string(),
                params: StepParams {
                    // Missing prompt
                    ..Default::default()
                },
                dependencies: vec![],
            }],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::MissingRequiredParam {
            step_id,
            task,
            param,
        }) = result
        {
            assert_eq!(step_id, "step_1");
            assert_eq!(task, "run_gemini");
            assert_eq!(param, "prompt");
        } else {
            panic!("Expected MissingRequiredParam error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_empty_prompt() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![Step {
                id: "step_1".to_string(),
                task: "run_gemini".to_string(),
                params: StepParams {
                    prompt: Some(String::new()), // Empty prompt
                    ..Default::default()
                },
                dependencies: vec![],
            }],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::MissingRequiredParam {
            step_id,
            task,
            param,
        }) = result
        {
            assert_eq!(step_id, "step_1");
            assert_eq!(task, "run_gemini");
            assert_eq!(param, "prompt");
        } else {
            panic!("Expected MissingRequiredParam error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_missing_filename() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![Step {
                id: "step_1".to_string(),
                task: "create_file".to_string(),
                params: StepParams {
                    // Missing filename
                    ..Default::default()
                },
                dependencies: vec![],
            }],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::MissingRequiredParam {
            step_id,
            task,
            param,
        }) = result
        {
            assert_eq!(step_id, "step_1");
            assert_eq!(task, "create_file");
            assert_eq!(param, "filename");
        } else {
            panic!("Expected MissingRequiredParam error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_empty_filename() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![Step {
                id: "step_1".to_string(),
                task: "create_file".to_string(),
                params: StepParams {
                    filename: Some(String::new()), // Empty filename
                    ..Default::default()
                },
                dependencies: vec![],
            }],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::MissingRequiredParam {
            step_id,
            task,
            param,
        }) = result
        {
            assert_eq!(step_id, "step_1");
            assert_eq!(task, "create_file");
            assert_eq!(param, "filename");
        } else {
            panic!("Expected MissingRequiredParam error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_with_dependencies() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write poem 1".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write poem 2".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![], // Can run in parallel with step_1
                },
                Step {
                    id: "step_3".to_string(),
                    task: "create_file".to_string(),
                    params: StepParams {
                        filename: Some("combined.txt".to_string()),
                        content_from: Some("step_1.output".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_1".to_string(), "step_2".to_string()],
                },
            ],
        };

        assert!(plan.validate().is_ok());
    }

    #[test]
    fn test_plan_validation_invalid_dependency() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![Step {
                id: "step_1".to_string(),
                task: "run_gemini".to_string(),
                params: StepParams {
                    prompt: Some("Write a test".to_string()),
                    ..Default::default()
                },
                dependencies: vec!["step_999".to_string()], // Invalid dependency!
            }],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::InvalidDependency {
            step_id,
            dependency,
        }) = result
        {
            assert_eq!(step_id, "step_1");
            assert_eq!(dependency, "step_999");
        } else {
            panic!("Expected InvalidDependency error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_circular_dependency() {
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write a test".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_2".to_string()], // step_1 depends on step_2
                },
                Step {
                    id: "step_2".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write another test".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_1".to_string()], // step_2 depends on step_1 - CYCLE!
                },
            ],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::CircularDependency { step_id }) = result {
            // Cycle detection will report one of the steps in the cycle
            assert!(step_id == "step_1" || step_id == "step_2");
        } else {
            panic!("Expected CircularDependency error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_circular_dependency_three_step() {
        // Test a longer cycle: step_1 -> step_2 -> step_3 -> step_1
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write test 1".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_3".to_string()],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write test 2".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_1".to_string()],
                },
                Step {
                    id: "step_3".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write test 3".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_2".to_string()], // Creates cycle: 1->3->2->1
                },
            ],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::CircularDependency { step_id: _ }) = result {
            // Cycle detected - good!
        } else {
            panic!("Expected CircularDependency error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_inconsistent_dependency() {
        // Test that if content_from references step_1, dependencies must include step_1
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write a test".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "create_file".to_string(),
                    params: StepParams {
                        filename: Some("test.txt".to_string()),
                        content_from: Some("step_1.output".to_string()), // References step_1
                        ..Default::default()
                    },
                    dependencies: vec![], // Missing step_1 in dependencies!
                },
            ],
        };

        let result = plan.validate();
        assert!(result.is_err());
        if let Err(ValidationError::InconsistentDependency {
            step_id,
            content_from,
            missing_dependency,
        }) = result
        {
            assert_eq!(step_id, "step_2");
            assert_eq!(content_from, "step_1.output");
            assert_eq!(missing_dependency, "step_1");
        } else {
            panic!("Expected InconsistentDependency error, got: {:?}", result);
        }
    }

    #[test]
    fn test_plan_validation_parallel_steps() {
        // Test a plan where multiple steps can run in parallel
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write poem 1".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write poem 2".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![], // Can run in parallel with step_1
                },
                Step {
                    id: "step_3".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write poem 3".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![], // Can run in parallel with step_1 and step_2
                },
                Step {
                    id: "step_4".to_string(),
                    task: "create_file".to_string(),
                    params: StepParams {
                        filename: Some("combined.txt".to_string()),
                        content_from: Some("step_1.output".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![
                        "step_1".to_string(),
                        "step_2".to_string(),
                        "step_3".to_string(),
                    ],
                },
            ],
        };

        assert!(plan.validate().is_ok());
    }

    #[test]
    fn test_plan_validation_diamond_dependency() {
        // Test diamond pattern: step_1 -> (step_2, step_3) -> step_4
        let plan = Plan {
            version: "1.0".to_string(),
            steps: vec![
                Step {
                    id: "step_1".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Write source".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec![],
                },
                Step {
                    id: "step_2".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Process part 1".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_1".to_string()],
                },
                Step {
                    id: "step_3".to_string(),
                    task: "run_gemini".to_string(),
                    params: StepParams {
                        prompt: Some("Process part 2".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_1".to_string()], // Can run in parallel with step_2
                },
                Step {
                    id: "step_4".to_string(),
                    task: "create_file".to_string(),
                    params: StepParams {
                        filename: Some("result.txt".to_string()),
                        content_from: Some("step_2.output".to_string()),
                        ..Default::default()
                    },
                    dependencies: vec!["step_2".to_string(), "step_3".to_string()],
                },
            ],
        };

        assert!(plan.validate().is_ok());
    }
}
